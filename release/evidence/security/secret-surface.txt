supabase/functions/moderate-image/index.ts:10: * - GOOGLE_VISION_API_KEY
supabase/functions/moderate-image/index.ts:74:    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
supabase/functions/moderate-image/index.ts:150:      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
supabase/functions/moderate-image/index.ts:176:    const apiKey = Deno.env.get('GOOGLE_VISION_API_KEY');
supabase/functions/moderate-image/index.ts:179:      console.warn('GOOGLE_VISION_API_KEY not set, skipping moderation');
src/lib/pushNotifications.ts:1:import { getMessaging, getToken, isSupported, onMessage } from 'firebase/messaging';
src/lib/pushNotifications.ts:2:import { firebaseApp, firebaseMessagingConfig, hasFirebaseMessagingConfig } from './firebase';
src/lib/pushNotifications.ts:14:  if (!hasFirebaseMessagingConfig || !firebaseApp) {
src/lib/pushNotifications.ts:30:  const encodedConfig = btoa(JSON.stringify(firebaseMessagingConfig));
src/lib/pushNotifications.ts:31:  const swUrl = `/firebase-messaging-sw.js?config=${encodeURIComponent(encodedConfig)}`;
src/lib/pushNotifications.ts:37:  const app = firebaseApp;
src/lib/pushNotifications.ts:53:  const token = await getToken(messaging, {
src/lib/pushNotifications.ts:58:  return token;
src/lib/pushNotifications.ts:63:  const app = firebaseApp;
public/firebase-messaging-sw.js:2:importScripts('https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js');
public/firebase-messaging-sw.js:3:importScripts('https://www.gstatic.com/firebasejs/10.12.2/firebase-messaging-compat.js');
public/firebase-messaging-sw.js:16:const firebaseConfig = readConfigFromUrl();
public/firebase-messaging-sw.js:17:if (!firebaseConfig) {
public/firebase-messaging-sw.js:21:  firebase.initializeApp(firebaseConfig);
public/firebase-messaging-sw.js:23:  const messaging = firebase.messaging();
mobile/src/services/supabase.ts:4: * Configured for React Native with secure token storage
mobile/src/services/supabase.ts:8:import * as SecureStore from 'expo-secure-store';
mobile/src/services/supabase.ts:24:      return localStorage.getItem(key);
mobile/src/services/supabase.ts:30:      localStorage.setItem(key, value);
mobile/src/services/supabase.ts:37:      localStorage.removeItem(key);
services/pushService.ts:4: * Handles push notification registration, token management, and preferences.
services/pushService.ts:17:  token: string;
services/pushService.ts:50:  async registerForPushNotificationsWeb(): Promise<{ token: string | null; error: Error | null }> {
services/pushService.ts:54:        return { token: null, error: new Error('This browser does not support notifications') };
services/pushService.ts:61:        return { token: null, error: new Error('Notification permission denied') };
services/pushService.ts:67:          return { token: null, error: new Error('Notification permission not granted') };
services/pushService.ts:71:      // Get Firebase messaging token
services/pushService.ts:73:      const { getMessaging, getToken } = await import('firebase/messaging');
services/pushService.ts:74:      const { firebaseApp } = await import('../src/lib/firebase');
services/pushService.ts:76:      if (!firebaseApp) {
services/pushService.ts:77:        return { token: null, error: new Error('Firebase not initialized') };
services/pushService.ts:80:      const messaging = getMessaging(firebaseApp);
services/pushService.ts:84:        return { token: null, error: new Error('VAPID key not configured') };
services/pushService.ts:87:      const token = await getToken(messaging, { vapidKey });
services/pushService.ts:89:      if (!token) {
services/pushService.ts:90:        return { token: null, error: new Error('Failed to get FCM token') };
services/pushService.ts:93:      // Save token to database
services/pushService.ts:94:      await this.saveToken(token, 'web');
services/pushService.ts:96:      return { token, error: null };
services/pushService.ts:98:      return { token: null, error: err as Error };
services/pushService.ts:106:  async registerForPushNotificationsMobile(): Promise<{ token: string | null; error: Error | null }> {
services/pushService.ts:115:        return { token: null, error: new Error('Push notifications require a physical device') };
services/pushService.ts:127:        return { token: null, error: new Error('Push notification permission not granted') };
services/pushService.ts:136:        return { token: null, error: new Error('Missing EAS projectId') };
services/pushService.ts:139:      const tokenData = await Notifications.getExpoPushTokenAsync({ projectId });
services/pushService.ts:140:      const token = tokenData.data;
services/pushService.ts:145:      // Save token to database
services/pushService.ts:146:      await this.saveToken(token, platform);
services/pushService.ts:157:      return { token, error: null };
services/pushService.ts:161:      return { token: null, error: err as Error };
services/pushService.ts:168:  async registerForPushNotifications(): Promise<{ token: string | null; error: Error | null }> {
services/pushService.ts:177:   * Save push token to database
services/pushService.ts:179:  async saveToken(token: string, platform: 'ios' | 'android' | 'web'): Promise<{ error: Error | null }> {
services/pushService.ts:187:        .from('push_tokens')
services/pushService.ts:191:            token,
services/pushService.ts:197:            onConflict: 'user_id,token',
services/pushService.ts:212:   * Remove push token (e.g., on logout)
services/pushService.ts:214:  async removeToken(token?: string): Promise<{ error: Error | null }> {
services/pushService.ts:222:        .from('push_tokens')
services/pushService.ts:226:      if (token) {
services/pushService.ts:227:        query = query.eq('token', token);
services/pushService.ts:243:   * Deactivate all tokens for current user
services/pushService.ts:253:        .from('push_tokens')
services/pushService.ts:268:   * Get current user's active tokens
services/pushService.ts:270:  async getActiveTokens(): Promise<{ tokens: PushToken[]; error: Error | null }> {
services/pushService.ts:274:        return { tokens: [], error: new Error('Not authenticated') };
services/pushService.ts:278:        .from('push_tokens')
services/pushService.ts:284:        return { tokens: [], error };
services/pushService.ts:287:      return { tokens: data || [], error: null };
services/pushService.ts:289:      return { tokens: [], error: err as Error };
services/pushService.ts:391:   * Request permission (without registering token)
src/lib/firebase.ts:1:import { FirebaseOptions, getApps, initializeApp } from 'firebase/app';
src/lib/firebase.ts:3:export const firebaseMessagingConfig: FirebaseOptions = {
src/lib/firebase.ts:12:  firebaseMessagingConfig.apiKey &&
src/lib/firebase.ts:13:    firebaseMessagingConfig.authDomain &&
src/lib/firebase.ts:14:    firebaseMessagingConfig.projectId &&
src/lib/firebase.ts:15:    firebaseMessagingConfig.messagingSenderId &&
src/lib/firebase.ts:16:    firebaseMessagingConfig.appId
src/lib/firebase.ts:21:export const firebaseApp = hasRequiredMessagingConfig
src/lib/firebase.ts:22:  ? getApps()[0] ?? initializeApp(firebaseMessagingConfig)
services/verificationService.ts:76:export const verifyOtp = async (email: string, token: string) => {
services/verificationService.ts:77:  return supabase.auth.verifyOtp({ email, token, type: 'email' });
supabase/functions/generate-icebreaker/index.ts:35:    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
supabase/functions/generate-icebreaker/index.ts:43:    return { user: null, error: new Error('Missing authorization token') };
supabase/functions/generate-icebreaker/index.ts:87:  const { user, error: authError } = await getAuthenticatedUser(req.headers.get('authorization'));
supabase/functions/generate-icebreaker/index.ts:113:    const apiKey = Deno.env.get('GEMINI_API_KEY');
src/lib/analytics.ts:13:let mixpanelInitialized = false;
src/lib/analytics.ts:14:let posthogInitialized = false;
src/lib/analytics.ts:15:let mixpanelClient: (typeof import('mixpanel-browser'))['default'] | null = null;
src/lib/analytics.ts:16:let posthogClient: (typeof import('posthog-js'))['default'] | null = null;
src/lib/analytics.ts:25:  const value = window.localStorage.getItem(CONSENT_STORAGE_KEY);
src/lib/analytics.ts:32:  window.localStorage.setItem(CONSENT_STORAGE_KEY, consent);
src/lib/analytics.ts:47:      const [mixpanelMod, posthogMod] = await Promise.all([
src/lib/analytics.ts:48:        MIXPANEL_TOKEN ? import('mixpanel-browser') : Promise.resolve(null),
src/lib/analytics.ts:49:        POSTHOG_KEY ? import('posthog-js') : Promise.resolve(null),
src/lib/analytics.ts:52:      mixpanelClient = mixpanelMod?.default ?? null;
src/lib/analytics.ts:53:      posthogClient = posthogMod?.default ?? null;
src/lib/analytics.ts:55:      if (MIXPANEL_TOKEN && mixpanelClient && !mixpanelInitialized) {
src/lib/analytics.ts:56:        mixpanelClient.init(MIXPANEL_TOKEN, { debug: false });
src/lib/analytics.ts:57:        mixpanelInitialized = true;
src/lib/analytics.ts:60:      if (POSTHOG_KEY && posthogClient && !posthogInitialized) {
src/lib/analytics.ts:61:        posthogClient.init(POSTHOG_KEY, {
src/lib/analytics.ts:62:          api_host: POSTHOG_HOST || 'https://app.posthog.com',
src/lib/analytics.ts:65:        posthogInitialized = true;
src/lib/analytics.ts:69:        if (mixpanelInitialized && mixpanelClient) mixpanelClient.identify(pendingIdentifyId);
src/lib/analytics.ts:70:        if (posthogInitialized && posthogClient) posthogClient.identify(pendingIdentifyId);
src/lib/analytics.ts:76:        if (mixpanelInitialized && mixpanelClient) mixpanelClient.track(evt.name, evt.props);
src/lib/analytics.ts:77:        if (posthogInitialized && posthogClient) posthogClient.capture(evt.name, evt.props);
src/lib/analytics.ts:85:    if (mixpanelInitialized && mixpanelClient) mixpanelClient.identify(pendingIdentifyId);
src/lib/analytics.ts:86:    if (posthogInitialized && posthogClient) posthogClient.identify(pendingIdentifyId);
src/lib/analytics.ts:94:  if (mixpanelInitialized && mixpanelClient) {
src/lib/analytics.ts:95:    mixpanelClient.track(name, props);
src/lib/analytics.ts:97:  if (posthogInitialized && posthogClient) {
src/lib/analytics.ts:98:    posthogClient.capture(name, props);
src/lib/analytics.ts:101:  if (!mixpanelInitialized && !posthogInitialized) {
services/accountService.ts:62:        localStorage.clear();
services/accountService.ts:63:        sessionStorage.clear();
services/authService.ts:43:    localStorage.clear();
services/authService.ts:44:    sessionStorage.clear();
src/lib/sentry.ts:4:  const dsn = import.meta.env.VITE_SENTRY_DSN as string | undefined;
src/lib/sentry.ts:14:        delete event.request.headers.authorization;
supabase/functions/webhooks-stripe/index.ts:43:  const stripeSecret = Deno.env.get('STRIPE_SECRET_KEY');
supabase/functions/webhooks-stripe/index.ts:44:  const webhookSecret = Deno.env.get('STRIPE_WEBHOOK_SECRET');
supabase/functions/webhooks-stripe/index.ts:46:  const supabaseServiceRole = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');
supabase/functions/push-worker/index.ts:36:  token: string;
supabase/functions/push-worker/index.ts:46:        'Access-Control-Allow-Headers': 'Authorization, x-cron-secret, Content-Type',
supabase/functions/push-worker/index.ts:56:    req.headers.get('x-cron-secret') ??
supabase/functions/push-worker/index.ts:69:    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
supabase/functions/push-worker/index.ts:106:    // Get push tokens for all recipients
supabase/functions/push-worker/index.ts:109:    const { data: tokens, error: tokenError } = await supabase
supabase/functions/push-worker/index.ts:110:      .from('push_tokens')
supabase/functions/push-worker/index.ts:111:      .select('user_id, token')
supabase/functions/push-worker/index.ts:115:    if (tokenError) {
supabase/functions/push-worker/index.ts:116:      console.error('Token fetch error:', tokenError);
supabase/functions/push-worker/index.ts:119:    // Build token map
supabase/functions/push-worker/index.ts:120:    const tokenMap = new Map<string, string[]>();
supabase/functions/push-worker/index.ts:121:    tokens?.forEach((t: PushToken) => {
supabase/functions/push-worker/index.ts:122:      const existing = tokenMap.get(t.user_id) || [];
supabase/functions/push-worker/index.ts:123:      existing.push(t.token);
supabase/functions/push-worker/index.ts:124:      tokenMap.set(t.user_id, existing);
supabase/functions/push-worker/index.ts:131:      const userTokens = tokenMap.get(notif.recipient_user_id);
supabase/functions/push-worker/index.ts:136:          p_error_message: 'No active push tokens',
supabase/functions/push-worker/index.ts:139:        results.push({ id: notif.id, success: false, error: 'No tokens' });
supabase/functions/push-worker/index.ts:144:      const messages = userTokens.map((token) => ({
supabase/functions/push-worker/index.ts:145:        to: token,
supabase/functions/push-worker/index.ts:179:          const token = userTokens[i];
supabase/functions/push-worker/index.ts:185:            await supabase.rpc('disable_push_token', { p_token: token });
supabase/functions/push-worker/index.ts:186:            console.log(`Disabled invalid token: ${token.substring(0, 20)}...`);
supabase/functions/push-worker/index.ts:198:            p_error_message: 'All tokens failed',
supabase/functions/push-worker/index.ts:201:          results.push({ id: notif.id, success: false, error: 'All tokens failed' });
supabase/functions/delete-account/index.ts:40:    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
supabase/functions/delete-account/index.ts:93:    Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
supabase/functions/create-checkout-session/index.ts:51:    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
supabase/functions/create-checkout-session/index.ts:59:    return { user: null, error: new Error('Missing authorization token') };
supabase/functions/create-checkout-session/index.ts:111:    const stripeSecret = Deno.env.get('STRIPE_SECRET_KEY');
supabase/functions/create-checkout-session/index.ts:118:      return new Response(JSON.stringify({ error: 'Missing STRIPE_SECRET_KEY' }), {
supabase/functions/create-checkout-session/index.ts:124:    const { user, error: authError } = await getAuthenticatedUser(req.headers.get('authorization'));
